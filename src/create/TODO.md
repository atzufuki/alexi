# @alexi/create Template Architecture TODO

This document tracks the architectural issues discovered during E2E test
development for the Todo app template generated by `@alexi/create`.

---

## ✅ COMPLETED: Template Architecture Fixes

The `home.ts` template has been refactored to follow the **View + Template
(MVT)** pattern. Templates are now purely presentational - all data fetching and
CRUD operations happen at the view level and are passed as props/callbacks.

### Changes Made

#### 1. ✅ Updated `templates/ui/templates/home_ts.ts`

- [x] Removed `rest` and `indexeddb` imports
- [x] Added `createTodo`, `toggleTodo`, `deleteTodo` callback props
- [x] Changed handlers to call props instead of doing CRUD directly
- [x] Template now only manages UI state (`newTodoTitle`, input clearing)

**Before (wrong):**

```typescript
// ❌ WRONG - Template imported and used backends directly
import { indexeddb, rest } from "@${name}-ui/settings.ts";

private handleSubmit = async (): Promise<void> => {
  const newTodo = await TodoModel.objects.using("rest").create({...});
  await indexeddb.insert(newTodo);  // Direct backend call
  if (this.fetch) await this.fetch();
};
```

**After (correct):**

```typescript
// ✅ CORRECT - Template receives callbacks as props
export class HomePage extends HTMLPropsMixin(HTMLElement, {
  loading: prop(false),
  todos: prop<QuerySet<TodoModel> | null>(null),
  fetch: prop<(() => Promise<void>) | null>(null),
  createTodo: prop<((title: string) => Promise<void>) | null>(null),
  toggleTodo: prop<((todo: TodoModel) => Promise<void>) | null>(null),
  deleteTodo: prop<((todo: TodoModel) => Promise<void>) | null>(null),
  newTodoTitle: prop(""),
}) {
  private handleSubmit = async (): Promise<void> => {
    const title = (this.newTodoTitle ?? "").trim();
    if (!title || !this.createTodo) return;
    this.newTodoTitle = "";
    await this.createTodo(title);
  };
}
```

#### 2. ✅ Updated `templates/ui/views_ts.ts`

- [x] Implemented `createTodo` callback using ORM
- [x] Implemented `toggleTodo` callback using ORM
- [x] Implemented `deleteTodo` callback using ORM
- [x] Pass callbacks to HomePage template via props
- [x] Handle IndexedDB caching in callbacks (not template)

**View now handles all CRUD:**

```typescript
export async function home(_ctx, _params): Promise<Node> {
  const { HomePage } = await import("@${name}-ui/templates/home.ts");
  const templateRef = ref<InstanceType<typeof HomePage>>();

  const fetch = async (): Promise<void> => {
    const fresh = await TodoModel.objects.using("rest").all().fetch();
    await fresh.using("indexeddb").save();
    templateRef.current!.todos = fresh;
  };

  const createTodo = async (title: string): Promise<void> => {
    const newTodo = await TodoModel.objects.using("rest").create({
      title,
      completed: false,
    });
    const qs = await TodoModel.objects.using("rest").filter({
      id: newTodo.id.get(),
    }).fetch();
    await qs.using("indexeddb").save();
    await fetch();
  };

  const toggleTodo = async (todo: TodoModel): Promise<void> => {
    const todoId = todo.id.get();
    const newCompleted = !todo.completed.get();
    await TodoModel.objects.using("rest").filter({ id: todoId }).update({
      completed: newCompleted,
    });
    todo.completed.set(newCompleted);
    const qs = await TodoModel.objects.using("rest").filter({ id: todoId })
      .fetch();
    await qs.using("indexeddb").save();
    await fetch();
  };

  const deleteTodo = async (todo: TodoModel): Promise<void> => {
    const todoId = todo.id.get();
    await TodoModel.objects.using("rest").filter({ id: todoId }).delete();
    await TodoModel.objects.using("indexeddb").filter({ id: todoId }).delete();
    await fetch();
  };

  return new HomePage({
    ref: templateRef,
    loading: count === 0,
    todos: cachedTodos,
    fetch,
    createTodo,
    toggleTodo,
    deleteTodo,
  });
}
```

#### 3. ✅ Fixed DSInput Component

- [x] Fixed `requestUpdate()` to always sync `this.value` to native input
- [x] Compare against native input's actual value, not just lastPropValue
- [x] Ensures programmatic value clearing (like after adding a todo) works

**Fix in `templates/ui/components/ds_input_ts.ts`:**

```typescript
override requestUpdate(): void {
  // Always sync value prop to native input when not handling user input
  if (!this.isHandlingInput && this.inputRef.current) {
    // Always sync if the native input's value differs from the prop
    if (this.inputRef.current.value !== this.value) {
      this.inputRef.current.value = this.value;
    }
    this.lastPropValue = this.value;
  }
  super.requestUpdate();
}
```

#### 4. ✅ Updated E2E Tests

- [x] Unskipped "should clear the input after adding a todo" test
- [ ] "should toggle todo completion when clicking checkbox" - **Still skipped**
      (see Known Issues below)

---

## Testing

Run the tests to verify all fixes work:

```bash
# Run scaffold tests (fast)
deno task test:scaffold

# Run E2E tests
deno task test:e2e

# Run all create package tests
deno task test:create
```

All tests should now pass (with 1 skipped test for known issue).

---

## Architecture Summary

### MVT Pattern (Model-View-Template)

| Layer    | Responsibility                                          |
| -------- | ------------------------------------------------------- |
| Model    | ORM models, database schema, field definitions          |
| View     | Data fetching, CRUD operations, business logic          |
| Template | Pure presentation, receives data and callbacks as props |

### Key Rules

1. **Templates MUST NOT import backends** - No `rest`, `indexeddb`, etc.
2. **Templates MUST NOT call ORM operations** - No `Model.objects.create()`,
   etc.
3. **Templates receive callbacks from views** - `createTodo`, `toggleTodo`, etc.
4. **Templates only manage UI state** - Input values, loading states, etc.
5. **Views implement callbacks using ORM** - `Model.objects.using("rest")...`
6. **Views handle caching** - Use `QuerySet.save()` with `.using("indexeddb")`

---

## Known Issues

### Toggle Test: Model Instance Endpoint Resolution

**Status:** Skipped test\
**Test:** "should toggle todo completion when clicking checkbox"

**Problem:**\
When a Model instance is fetched from IndexedDB and then passed to
`rest.update(todo)`, the RestBackend fails to resolve the endpoint correctly,
resulting in a `/apiundefined` request. This happens because:

1. Model instances fetched from IndexedDB don't retain endpoint mapping metadata
2. `RestBackend.getEndpointForModel()` relies on `modelClass.name` matching
   registered endpoints
3. The mapping may not be preserved when instances cross backend boundaries

**Error:**

```
Failed to load resource: 404 Not Found (http://localhost:9200/apiundefined)
```

**Workaround:**\
Use QuerySet operations instead of instance methods, or ensure model instances
are fetched from the REST backend before updating:

```typescript
// Instead of:
await rest.update(todo); // May fail if todo came from IndexedDB

// Do:
const freshTodo = await TodoModel.objects.using(rest).filter({
  id: todo.id.get(),
}).first();
if (freshTodo) {
  freshTodo.completed.set(!freshTodo.completed.get());
  await rest.update(freshTodo);
}
```

**Fix needed:**\
The ORM layer should track the model class reference independently of how/where
the instance was created. One approach: store the model class constructor on
instances during hydration so that backend methods can reliably resolve
endpoints.
